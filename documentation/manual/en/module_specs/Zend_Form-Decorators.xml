<?xml version="1.0" encoding="utf-8"?>


<section xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="zend.form.decorators"><info><title>Creating Custom Form Markup Using Zend_Form_Decorator</title></info>
    

    <para>
        Rendering a form object is completely optional -- you do not need to use
        <classname>Zend_Form</classname>'s render() methods at all. However, if you do,
        decorators are used to render the various form objects.
    </para>

    <para>
        An arbitrary number of decorators may be attached to each item
        (elements, display groups, sub forms, or the form object itself);
        however, only one decorator of a given type may be attached to each
        item. Decorators are called in the order they are registered. Depending
        on the decorator, it may replace the content passed to it, or append or
        prepend the content.
    </para>

    <para>
        Object state is set via configuration options passed to the constructor
        or the decorator's <methodname>setOptions()</methodname> method. When creating
        decorators via an item's <methodname>addDecorator()</methodname> or related methods,
        options may be passed as an argument to the method. These can be used to
        specify placement, a separator to use between passed in content and
        newly generated content, and whatever options the decorator supports.
    </para>

    <para>
        Before each decorator's <methodname>render()</methodname> method is called, the
        current item is set in the decorator using <methodname>setElement()</methodname>,
        giving the decorator awareness of the item being rendered. This allows
        you to create decorators that only render specific portions of the item
        -- such as the label, the value, error messages, etc. By stringing
        together several decorators that render specific element segments, you
        can build complex markup representing the entire item.
    </para>

    <section xml:id="zend.form.decorators.operation"><info><title>Operation</title></info>
        

        <para>
            To configure a decorator, pass an array of options or a
            <classname>Zend_Config</classname> object to its constructor, an array to
            <methodname>setOptions()</methodname>, or a <classname>Zend_Config</classname> object to
            <methodname>setConfig()</methodname>.
        </para>

        <para>
            Standard options include:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <property>placement</property>: Placement can be either 'append' or
                    'prepend' (case insensitive), and indicates whether content
                    passed to <methodname>render()</methodname> will be appended or
                    prepended, respectively. In the case that a decorator
                    replaces the content, this setting is ignored. The default
                    setting is to append.
                </para>
            </listitem>

            <listitem>
                <para>
                    <property>separator</property>: The separator is used between the
                    content passed to <methodname>render()</methodname> and new content
                    generated by the decorator, or between items rendered by the
                    decorator (e.g. FormElements uses the separator between each
                    item rendered). In the case that a decorator replaces the
                    content, this setting may be ignored. The default value is
                    <constant>PHP_EOL</constant>.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            The decorator interface specifies methods for interacting with
            options. These include:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <methodname>setOption($key, $value)</methodname>: set a single option.
                </para>
            </listitem>

            <listitem>
                <para>
                    <methodname>getOption($key)</methodname>: retrieve a single option value.
                </para>
            </listitem>

            <listitem>
                <para>
                    <methodname>getOptions()</methodname>: retrieve all options.
                </para>
            </listitem>

            <listitem>
                <para>
                    <methodname>removeOption($key)</methodname>: remove a single option.
                </para>
            </listitem>

            <listitem>
                <para>
                    <methodname>clearOptions()</methodname>: remove all options.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Decorators are meant to interact with the various
            <classname>Zend_Form</classname> class types: <classname>Zend_Form</classname>,
            <classname>Zend_Form_Element</classname>, <classname>Zend_Form_DisplayGroup</classname>,
            and all classes deriving from them. The method
            <methodname>setElement()</methodname> allows you to set the object the
            decorator is currently working with, and <methodname>getElement()</methodname>
            is used to retrieve it.
        </para>

        <para>
            Each decorator's <methodname>render()</methodname> method accepts a string,
            <varname>$content</varname>. When the first decorator is called, this
            string is typically empty, while on subsequent calls it will be
            populated. Based on the type of decorator and the options passed in,
            the decorator will either replace this string, prepend the string,
            or append the string; an optional separator will be used in the
            latter two situations.
        </para>
    </section>

    <section xml:id="zend.form.decorators.standard"><info><title>Standard Decorators</title></info>
        

        <para>
            <classname>Zend_Form</classname> ships with many standard decorators; see
            <link linkend="zend.form.standardDecorators">the chapter on Standard
            Decorators</link> for details.
        </para>
    </section>

    <section xml:id="zend.form.decorators.custom"><info><title>Custom Decorators</title></info>
        

        <para>
            If you find your rendering needs are complex or need heavy
            customization, you should consider creating a custom decorator.
        </para>

        <para>
            Decorators need only implement
            <classname>Zend_Form_Decorator_Interface</classname>. The interface specifies the
            following:
        </para>

        <programlisting language="php">
interface Zend_Form_Decorator_Interface
{
    public function __construct($options = null);
    public function setElement($element);
    public function getElement();
    public function setOptions(array $options);
    public function setConfig(Zend_Config $config);
    public function setOption($key, $value);
    public function getOption($key);
    public function getOptions();
    public function removeOption($key);
    public function clearOptions();
    public function render($content);
}
</programlisting>

        <para>
            To make this simpler, you can simply extend
            <classname>Zend_Form_Decorator_Abstract</classname>, which implements all methods
            except <methodname>render()</methodname>.
        </para>

        <para>
            As an example, let's say you want to reduce the number of
            decorators you use, and build a "composite" decorator to take care
            of rendering the label, element, any error messages, and description
            in an <acronym>HTML</acronym> 'div'. You might build such a 'Composite'
            decorator as follows:
        </para>

        <programlisting language="php">
class My_Decorator_Composite extends Zend_Form_Decorator_Abstract
{
    public function buildLabel()
    {
        $element = $this-&gt;getElement();
        $label = $element-&gt;getLabel();
        if ($translator = $element-&gt;getTranslator()) {
            $label = $translator-&gt;translate($label);
        }
        if ($element-&gt;isRequired()) {
            $label .= '*';
        }
        $label .= ':';
        return $element-&gt;getView()
                       -&gt;formLabel($element-&gt;getName(), $label);
    }

    public function buildInput()
    {
        $element = $this-&gt;getElement();
        $helper  = $element-&gt;helper;
        return $element-&gt;getView()-&gt;$helper(
            $element-&gt;getName(),
            $element-&gt;getValue(),
            $element-&gt;getAttribs(),
            $element-&gt;options
        );
    }

    public function buildErrors()
    {
        $element  = $this-&gt;getElement();
        $messages = $element-&gt;getMessages();
        if (empty($messages)) {
            return '';
        }
        return '&lt;div class="errors"&gt;' .
               $element-&gt;getView()-&gt;formErrors($messages) . '&lt;/div&gt;';
    }

    public function buildDescription()
    {
        $element = $this-&gt;getElement();
        $desc    = $element-&gt;getDescription();
        if (empty($desc)) {
            return '';
        }
        return '&lt;div class="description"&gt;' . $desc . '&lt;/div&gt;';
    }

    public function render($content)
    {
        $element = $this-&gt;getElement();
        if (!$element instanceof Zend_Form_Element) {
            return $content;
        }
        if (null === $element-&gt;getView()) {
            return $content;
        }

        $separator = $this-&gt;getSeparator();
        $placement = $this-&gt;getPlacement();
        $label     = $this-&gt;buildLabel();
        $input     = $this-&gt;buildInput();
        $errors    = $this-&gt;buildErrors();
        $desc      = $this-&gt;buildDescription();

        $output = '&lt;div class="form element"&gt;'
                . $label
                . $input
                . $errors
                . $desc
                . '&lt;/div&gt;'

        switch ($placement) {
            case (self::PREPEND):
                return $output . $separator . $content;
            case (self::APPEND):
            default:
                return $content . $separator . $output;
        }
    }
}
</programlisting>

        <para>
            You can then place this in the decorator path:
        </para>

        <programlisting language="php">
// for an element:
$element-&gt;addPrefixPath('My_Decorator',
                        'My/Decorator/',
                        'decorator');

// for all elements:
$form-&gt;addElementPrefixPath('My_Decorator',
                            'My/Decorator/',
                            'decorator');
</programlisting>

        <para>
            You can then specify this decorator as 'Composite' and attach it to
            an element:
        </para>

        <programlisting language="php">
// Overwrite existing decorators with this single one:
$element-&gt;setDecorators(array('Composite'));
</programlisting>

        <para>
            While this example showed how to create a decorator that renders
            complex output from several element properties, you can also create
            decorators that handle a single aspect of an element; the
            'Decorator' and 'Label' decorators are excellent examples of this
            practice. Doing so allows you to mix and match decorators to achieve
            complex output -- and also override single aspects of decoration to
            customize for your needs.
        </para>

        <para>
            For example, if you wanted to simply display that an error occurred
            when validating an element, but not display each of the individual
            validation error messages, you might create your own 'Errors'
            decorator:
        </para>

        <programlisting language="php">
class My_Decorator_Errors
{
    public function render($content = '')
    {
        $output = '&lt;div class="errors"&gt;The value you provided was invalid;
            please try again&lt;/div&gt;';

        $placement = $this-&gt;getPlacement();
        $separator = $this-&gt;getSeparator();

        switch ($placement) {
            case 'PREPEND':
                return $output . $separator . $content;
            case 'APPEND':
            default:
                return $content . $separator . $output;
        }
    }
}
</programlisting>

        <para>
            In this particular example, because the decorator's final segment,
            'Errors', matches the same as <classname>Zend_Form_Decorator_Errors</classname>,
            it will be rendered <emphasis>in place of</emphasis> that decorator
            -- meaning you would not need to change any decorators to modify the
            output. By naming your decorators after existing standard
            decorators, you can modify decoration without needing to modify your
            elements' decorators.
        </para>
    </section>

    <section xml:id="zend.form.decorators.individual"><info><title>Rendering Individual Decorators</title></info>
        

        <para>
            Since decorators can target distinct metadata of the element or form
            they decorate, it's often useful to render one individual decorator
            at a time. This behavior is possible via method
            overloading in each major form class type (forms, sub form, display
            group, element).
        </para>

        <para>
            To do so, simply call <methodname>render[DecoratorName]()</methodname>, where
            "[DecoratorName]" is the "short name" of your decorator; optionally,
            you can pass in content you want decorated. For example:
        </para>

        <programlisting language="php">
// render just the element label decorator:
echo $element-&gt;renderLabel();

// render just the display group fieldset, with some content:
echo $group-&gt;renderFieldset('fieldset content');

// render just the form HTML tag, with some content:
echo $form-&gt;renderHtmlTag('wrap this content');
</programlisting>

        <para>
            If the decorator does not exist, an exception is raised.
        </para>

        <para>
            This can be useful particularly when rendering a form with the
            ViewScript decorator; each element can use its attached decorators
            to generate content, but with fine-grained control.
        </para>
    </section>
</section>
