<?xml version="1.0" encoding="UTF-8"?>
<!-- Reviewed: no -->
<section 
    xmlns="http://docbook.org/ns/docbook" version="5.0"
    xml:id="zend.mvc.examples">
  <info><title>Examples</title></info>

  <section xml:id="zend.mvc.examples.controllers">
    <info><title>Controllers</title></info>

    <section xml:id="zend.mvc.examples.controllers.accessing-the-request-and-response">
      <info><title>Accessing the Request and Response</title></info>

      <para>
        When using <classname>ActionController</classname> or
        <classname>RestfulController</classname>, the request and response
        object are composed directly into the controller as soon as
        <methodname>dispatch()</methodname> is called. You may access them in the
        following ways:
      </para>

      <programlisting language="php"><![CDATA[
$request  = $this->getRequest();
$response = $this->getResponse();

$request  = $this->request;
$response = $this->response;
]]></programlisting>

      <para>
        Additionally, if your controller implements
        <classname>InjectApplicationEvent</classname> (as both
        <classname>ActionController</classname> and
        <classname>RestfulController</classname> do), you can access these
        objects from the attached <classname>MvcEvent</classname>:
      </para>

      <programlisting language="php"><![CDATA[
$event    = $this->getEvent();
$request  = $event->getRequest();
$response = $event->getResponse();
]]></programlisting>

      <para>
        The above can be useful when composing event listeners into your
        controller.
      </para>
    </section>

    <section xml:id="zend.mvc.examples.controllers.accessing-routing-parameters">
      <info><title>Accessing routing parameters</title></info>

      <para>
        The parameters returned when routing completes are wrapped in a
        <classname>Zend\Mvc\Router\RouteMatch</classname> object. This object
        is detailed in the section on routing.
      </para>

      <para>
        Within your controller, if you implement
        <classname>InjectApplicationEvent</classname> (as both
        <classname>ActionController</classname> and
        <classname>RestfulController</classname> do), you can access this
        object from the attached <classname>MvcEvent</classname>:
      </para>

      <programlisting language="php"><![CDATA[
$event   = $this->getEvent();
$matches = $event->getRouteMatch();
]]></programlisting>

      <para>
        Once you have the <classname>RouteMatch</classname> object, you can
        pull parameters from it.
      </para>
    </section>

    <section xml:id="zend.mvc.examples.controllers.returning-early">
      <info><title>Returning early</title></info>

      <para>
        You can effectively short-circuit execution of the application at
        any point by returning a <classname>Response</classname> from your
        controller or any event. When such a value is discovered, it halts
        further execution of the event manager, bubbling up to the
        <classname>Application</classname> instance, where it is immediately
        returned.
      </para>

      <para>
        As an example, the <classname>Redirect</classname> plugin returns a
        <classname>Response</classname>, which can be returned immediately so
        as to complete the request as quickly as possible. Other use cases
        might be for returning JSON or XML results from web service
        endpoints, returning "401 Forbidden" results, etc.
      </para>
    </section>
  </section>

  <section xml:id="zend.mvc.examples.bootstrapping">
    <info><title>Bootstrapping</title></info>

    <section xml:id="registering-module-specific-listeners">
      <info><title>Registering module-specific listeners</title></info>

      <para>
        Often you may want module-specific listeners. As an example, this
        would be a simple and effective way to introduce authorization,
        logging, or caching into your application.
      </para>

      <para>
        One convention being used is as follows:
      </para>

      <itemizedlist>
        <listitem>
          <para>
            If your module needs to register listeners with the
            <classname>Application</classname> event manager instance, define a
            "registerApplicationListeners" method that accepts the
            <classname>Application</classname> as an argument.
          </para>
        </listitem>

        <listitem>
          <para>
            If your module needs to register arbitrary listeners statically,
            define a "registerStaticListeners" method that accepts a
            <classname>StaticEventCollection</classname> implementation and Locator
            instance.
          </para>
        </listitem>
      </itemizedlist>

      <para>
        Then, in your bootstrap, setup something like the following:
      </para>

      <programlisting language="php"><![CDATA[
use Zend\Mvc\Application,
    Zend\Module\Manager,
    Zend\EventManager\StaticEventManager;

class Bootstrap
{
    protected $config;
    protected $manager;

    public function __construct(Manager $manager)
    {
        $this->manager = $manager;
        $this->config  = $manager->getMergedConfig();
    }

    public function bootstrap(Application $app)
    {
        $this->setupLocator($app);
        $this->setupEvents($app);

        // anything else you need to do...
    }

    public function setupLocator(Application $app)
    {
        /* ... */
    }

    public function setupEvents(Application $app)
    {
        $locator      = $app->getLocator();
        $events       = $app->events();
        $staticEvents = StaticEventManager::getInstance();

        foreach ($this->manager->getLoadedModules() as $name => $module) {
            if (method_exists($module, 'registerApplicationListeners')) {
                $module->registerApplicationListeners($events, $locator, $this->config);
            }

            if (method_exists($module, 'registerStaticListeners')) {
                $module->registerStaticListeners($staticEvents, $locator, $this->config);
            }
        }
    }
}
]]></programlisting>

      <para>
        The above makes the assumption that your
        <filename>public/index.php</filename> script will do the following:
      </para>

      <programlisting language="php"><![CDATA[
// assume module manager is configured
$bootstrap = new Bootstrap($manager);
$bootstrap->bootstrap($application);
]]></programlisting>

      <para>
        Basically, the bootstrap accepts the module manager, and pulls the
        merged config from it. As part of bootstrapping, it attempts to
        setup events. It does this by looping over the registered modules,
        looking for any that define either the
        <methodname>registerApplicationListeners</methodname> or
        <methodname>registerStaticListeners</methodname> methods, and calling
        them if found.
      </para>

      <para>
        A module can then define these, and register events as necessary.
      </para>
    </section>
  </section>
</section>
